[
["index.html", "Using R at Grattan Institute Introduction", " Using R at Grattan Institute Will Mackey and Matt Cowgill 2019-08-15 Introduction R is good and cool. Do you want to be good and cool? Use R! "],
["intro.html", "1 Using R at Grattan 1.1 Why use R? 1.2 Using R projects for a fully reproducible workflow. 1.3 Grattan coding style guide 1.4 What is the tidyverse and why do we use it? 1.5 An introduction to RMarkdown 1.6 Resources in this package", " 1 Using R at Grattan library(tidyverse) This document sets out good practices for structuring your R analysis at Grattan Institute. Having a clear, consistent structure for our analyses means that our work is more easily checked and revised, including by ourselves in the future. A small investment of time up front to set up your analysis will save time (your own and others’) down the track. This guide is designed for everyone using R at Grattan. It includes a combination of rules and guidelines. You should also be aware of the Grattan Institute R Style Guide, which lives in the same place as this document. Any compaints or comments about this guide can be sent to Will or Matt, respectively. 1.1 Why use R? It’s good and cool! 1.2 Using R projects for a fully reproducible workflow. Finally adhering to the ‘hit by a bus’ rule. Cover: 1. setwd() and machine-speficic filepaths are bad 2. relative file paths are good 3. RStudio projects are an easy, reproducible way to set your wd 1.2.1 Filepaths Filepaths should be relative to the working directory, and the working directory should be set by the project. Good hes &lt;- read_csv(&quot;data/HES/hes1516.csv&quot;) grattan_save(&quot;images/expenditure_by_income.pdf&quot;) Bad hes &lt;- read_csv(&quot;/Users/mcowgill/Desktop/hes1516.csv&quot;) hes &lt;- read_csb(&quot;C:\\Users\\mcowgill\\Desktop\\hes1516.csv&quot;) grattan_save(&quot;/Users/mcowgill/Desktop/images/expenditure_by_income.pdf&quot;) 1.2.2 Keep your scripts manageable As a general rule of thumb, use one script per output. It should be clear what your script is trying to do (use comments!). Consider breaking your analysis into pieces. For example: 01_import.R 02_tidy.R 03_model.R 04_visualise.R Don’t include interactive work (like View(mydf), str(mydf), mean(mydf$variable), etc.) in your saved script. 1.2.3 Use subfolders of your project folder Remember the hit-by-a-bus rule. It should be easy for any Grattan colleague to open your project folder and get up to speed with what it does. Putting all your files - raw data, scripts, output - in the one folder makes it harder to understand how your work fits together. Use subfolders to clearly separate your code, raw data, and output. 1.3 Grattan coding style guide Short summary of why Link to style guide 1.4 What is the tidyverse and why do we use it? Introduce following chapters 1.5 An introduction to RMarkdown 1.6 Resources in this package Starting a piece of analysis ‘cheat sheet’. Updated style guide. Written guide/slides. "],
["data-visualisation.html", "2 Data Visualisation 2.1 Set-up and packages 2.2 Concepts 2.3 Making Grattan-y charts 2.4 Chart cookbook 2.5 Creating simple interactive graphs with plotly 2.6 bin: generate data used (before prior sections are constructed)", " 2 Data Visualisation [intro] 2.1 Set-up and packages This section uses the package ggplot2 to visualise data, and dplyr functions to manipulate data. Both of these packages are loaded with tidyverse. The scales package is handy for nicely labelling your axes. The grattantheme package is used to make charts look Grattan-y. The absmapsdata package is used to help make maps. library(tidyverse) library(grattantheme) library(absmapsdata) library(sf) library(scales) For most charts in this chapter, we’ll use the population_table data summarised here. It contains the population in each state between 2013 and 2018: population_table &lt;- read_csv(&quot;data/population_sa4.csv&quot;) %&gt;% mutate(state_long = state, state = strayr::strayr(state_long)) %&gt;% filter(data_item == &quot;Persons - Total (no.)&quot;) %&gt;% mutate(pop = as.numeric(value), year = as.factor(year)) %&gt;% group_by(year, state) %&gt;% summarise(pop = sum(pop)) # Show the first six rows of the new dataset head(population_table) ## # A tibble: 6 x 3 ## # Groups: year [1] ## year state pop ## &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 2013 ACT 383257 ## 2 2013 NSW 7404032 ## 3 2013 NT 244684 ## 4 2013 Qld 4652824 ## 5 2013 SA 1671488 ## 6 2013 Tas 512231 2.2 Concepts The ggplot2 package is based on the grammar of graphics. … The main ingredients to a ggplot chart: Data: what data should be plotted. e.g. data Aesthetics: what variables should be linked to what chart elements. e.g. aes(x = population, y = age) to connect the population variable to the x axis, and the age variable to the y axis. Geoms: how the data should be plotted. e.g. geom_point() will produce a scatter plot, geom_col will produce a column chart. Each plot you make will be made up of these three elements. The full list of standard geoms is listed in the tidyverse documentation. ggplot(data = &lt;DATA&gt;) + &lt;GEOM_FUNCTION&gt;( mapping = aes(&lt;MAPPINGS&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) + &lt;COORDINATE_FUNCTION&gt; + &lt;FACET_FUNCTION&gt; For example, you can plot a column chart by passing the population_table dataset into ggplot() (“make a chart wth this data”). This produces an empty plot: population_table %&gt;% ggplot() Next, set the aes (aesthetics) to x = state (“make the x-axis represent state”), y = pop (“the y-axis should represent population”), and fill = year (“the fill colour represents year”). Now ggplot knows where things should go: population_table %&gt;% ggplot(aes(x = state, y = pop, fill = year)) Now that ggplot knows where things should go, it needs to how to plot them. For this we use geoms. Tell it to plot a column chart by using geom_col: population_table %&gt;% ggplot(aes(x = state, y = pop, fill = year)) + geom_col() Great! Although stacking populations is a bit silly. You can adjust the way geoms work with arguments. In this case, tell it to place the different categories next to each other rather than ontop of each other using position = &quot;dodge&quot;: population_table %&gt;% ggplot(aes(x = state, y = pop, fill = year)) + geom_col(position = &quot;dodge&quot;) That’s nicer. The following sections in this chapter will build on this chart. The rest of the chapter will explore: Grattanising your charts and choosing colours Saving charts according to Grattan templates Making bar, line, scatter and distribution plots Making maps and interactive charts Adding chart labels 2.3 Making Grattan-y charts The grattantheme package contains functions that help Grattanise your charts. It is hosted here: https://github.com/mattcowgill/grattantheme You can install it with devtools::install_github from the package: install.packages(&quot;devtools&quot;) remotes::install_github(&quot;mattcowgill/grattantheme&quot;) The key functions of grattantheme are: theme_grattan: set size, font and colour defaults that adhere to the Grattan style guide. grattan_y_continuous: sets the right defaults for a continuous y-axis. grattan_colour_continuous: pulls colours from the Grattan colour palete for colour aesthetics. grattan_fill_continuous: pulls colours from the Grattan colour palete for fill aesthetics. grattan_save: a save function that exports charts in correct report or presentation dimensions. This section will run through some examples of Grattanising charts. The ggplot functions are explored in more detail in the next section. 2.3.1 Making Grattan charts Start with a column chart, similar to the one made above: base_chart &lt;- population_table %&gt;% ggplot(aes(x = state, y = pop, fill = year)) + geom_col(position = &quot;dodge&quot;) + labs(x = &quot;&quot;, title = &quot;NSW and Victoria are booming&quot;, subtitle = &quot;Population by state, 2013-2018&quot;, caption = &quot;Source: ABS Regional Dataset (2019)&quot;) base_chart Let’s make it Grattany. First, add theme_grattan to your plot: base_chart + theme_grattan() Then grattan_y_continuous to align the x-axis with zero. This function takes the same arguments as scale_y_continuous, so you can add labels = comma() to reformat the y-axis labels: base_chart + theme_grattan() + grattan_y_continuous(labels = comma) To define fill colours, use grattan_fill_manual with the number of colours you need (six, in this case): pop_chart &lt;- base_chart + theme_grattan() + grattan_y_continuous(labels = comma) + grattan_fill_manual(6) pop_chart Nice chart! Now you can save it and share it with the world. 2.3.2 Saving Grattan charts The grattan_save function saves your charts according to Grattan templates. It takes these arguments: filename: the path, name and file-type of your saved chart. eg: &quot;atlas/population_chart.pdf&quot;. object: the R object that you want to save. eg: pop_chart. If left blank, it grabs the last chart that was displayed. type: the Grattan template to be used. This is one of: &quot;normal&quot; The default. Use for normal Grattan report charts, or to paste into a 4:3 Powerpoint slide. Width: 22.2cm, height: 14.5cm. &quot;normal_169&quot; Only useful for pasting into a 16:9 format Grattan Powerpoint slide. Width: 30cm, height: 14.5cm. &quot;tiny&quot; Fills the width of a column in a Grattan report, but is shorter than usual. Width: 22.2cm, height: 11.1cm. &quot;wholecolumn&quot; Takes up a whole column in a Grattan report. Width: 22.2cm, height: 22.2cm. &quot;fullpage&quot; Fills a whole page of a Grattan report. Width: 44.3cm, height: 22.2cm. &quot;fullslide&quot; Creates an image that looks like a 4:3 Grattan Powerpoint slide, complete with logo. Width: 25.4cm, height: 19.0cm. &quot;fullslide_169&quot; Creates` an image that looks like a 16:9 Grattan Powerpoint slide, complete with logo. Use this to drop into standard presentations. Width: 33.9cm, height: 19.0cm &quot;blog&quot; Creates a 4:3 image that looks like a Grattan Powerpoint slide, but with less border whitespace than ‘fullslide’.&quot; &quot;fullslide_44&quot; Creates an image that looks like a 4:4 Grattan Powerpoint slide. This may be useful for taller charts for the Grattan blog; not useful for any other purpose. Width: 25.4cm, height: 25.4cm. Set type = &quot;all&quot; to save your chart in all available sizes. height: override the height set by type. This can be useful for really long charts in blogposts. save_data: exports a csv file containing the data used in the chart. force_labs: override the removal of labels for a particular type. eg force_labs = TRUE will keep the y-axis label. To save the pop_chart plot created above as a whole-column chart for a report: grattan_save(&quot;atlas/population_chart_report.pdf&quot;, pop_chart, type = &quot;wholecolumn&quot;) To save it as a presentation slide instead, use type = &quot;fullslide&quot;: grattan_save(&quot;atlas/population_chart_presentation.pdf&quot;, pop_chart, type = &quot;fullslide&quot;) Or, if you want to emphasise the point in a really tall chart for a blogpost, you can use type = &quot;blog&quot; and adjust the height to be 50cm. Also note that because this is for the blog, you should save it as a png file: grattan_save(&quot;atlas/population_chart_blog.png&quot;, pop_chart, type = &quot;blog&quot;, height = 50) And that’s it! The following sections will go into more detail about different chart types in R, but you’ll mostly use the same basic grattantheme formatting you’ve used here. 2.4 Chart cookbook This section takes you through a few often-used chart types. 2.4.1 Bar charts Bar charts are made with geom_bar or geom_col. Creating a bar chart will look something like this: ggplot(data = &lt;data&gt;) + geom_bar(aes(x = &lt;xvar&gt;, y = &lt;yvar&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) It has two key arguments: stat and position. First, stat defines what kind of operation the function will do on the dataset before plotting. Some options are: &quot;count&quot;, the default: count the number of observations in a particular group, and plot that number. This is useful when you’re using microdata. When this is the case, there is no need for a y aesthetic. &quot;sum&quot;: sum the values of the y aesthetic. &quot;identity&quot;: directly report the values of the y aesthetic. This is how Powerpoint and Excel charts work. You can use geom_col instead, as a shortcut for geom_bar(stat = &quot;identity). Second, position, dictates how multiple bars occupying the same x-axis position will positioned. The options are: &quot;stack&quot;, the default: bars in the same group are stacked atop one another. &quot;dodge&quot;: bars in the same group are positioned next to one another. &quot;fill&quot;: bars in the same group are stacked and all fill to 100 per cent. population_table %&gt;% ggplot(aes(x = state, y = pop, fill = year)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + theme_grattan() + grattan_y_continuous(labels = comma) + grattan_fill_manual(6) You can also order the groups in your chart by a variable. If you want to order states by population, use reorder inside aes: population_table %&gt;% ggplot(aes(x = reorder(state, -pop), # reorder state by negative population y = pop, fill = year)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + theme_grattan() + grattan_y_continuous(labels = comma) + grattan_fill_manual(6) + labs(x = &quot;&quot;) To flip the chart – a useful move when you have long labels – add coord_flipped (ie ‘flip coordinates’) and tell theme_grattan that the plot is flipped using flipped = TRUE. population_table %&gt;% ggplot(aes(x = reorder(state, -pop), y = pop, fill = year)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + coord_flip() + # flip the coordinates theme_grattan(flipped = TRUE) + # tell theme_grattan grattan_y_continuous(labels = comma) + grattan_fill_manual(6) + labs(x = &quot;&quot;) 2.4.2 Line charts A line chart has one key aesthetic: group. This tells ggplot how to connect individual lines. population_table %&gt;% ggplot(aes(x = year, y = pop, colour = state, group = state)) + geom_line() + theme_grattan() + grattan_y_continuous(labels = comma) + grattan_colour_manual(8) + labs(x = &quot;&quot;) ## Warning in grattantheme::grattan_pal(n = n, reverse = reverse): Using more ## than six colours is not recommended. You can also add dots for each year by layering geom_point on top of geom_line: population_table %&gt;% ggplot(aes(x = year, y = pop, colour = state, group = state)) + geom_line() + geom_point(size = 2) + theme_grattan() + grattan_y_continuous(labels = comma) + grattan_colour_manual(8) + labs(x = &quot;&quot;) ## Warning in grattantheme::grattan_pal(n = n, reverse = reverse): Using more ## than six colours is not recommended. If you wanted to show each state individually, you could facet your chart so that a separate plot was produced for each state: population_table %&gt;% filter(state != &quot;ACT&quot;, state != &quot;NT&quot;) %&gt;% ggplot(aes(x = year, y = pop, group = state)) + geom_line() + geom_point(size = 2) + theme_grattan() + grattan_y_continuous() + facet_wrap(state ~ .) + labs(x = &quot;&quot;) To tidy this up, we can: shorten the years to be “13”, “14”, etc instead of “2013”, “2014”, etc (via the x aesthetic) shorten the y-axis labels to “millions” (via the y aesthetic) add a black horizontal line at the bottom of each facet give the facets a bit of room by adjusting panel.spacing define our own x-axis label breaks to just show 13, 15 and 17 population_table %&gt;% filter(state != &quot;ACT&quot;, state != &quot;NT&quot;) %&gt;% ggplot(aes(x = substr(year, 3, 4), # 1: just take the last two characters y = pop / 1e6, # 2: divide population by one million group = state)) + geom_line() + geom_point(size = 2) + geom_hline(yintercept = 0) + # 3: add horizontal line at the bottom theme_grattan() + theme(panel.spacing = unit(10, &quot;mm&quot;)) + # 4: add panel spacing grattan_y_continuous(labels = comma) + scale_x_discrete(breaks = c(&quot;13&quot;, &quot;15&quot;, &quot;17&quot;)) + # 5: define our own label breaks facet_wrap(state ~ .) + labs(x = &quot;&quot;) 2.4.3 Scatter plots Scatter plots require x and y aesthetics. These can then be coloured and facetted. First, create a dataset that we’ll use for scatter plots. Take the population_table dataset and transform it to have one variable for population in 2013, and another for population in 2018: population_diff &lt;- read_csv(&quot;data/population_sa4.csv&quot;) %&gt;% mutate(state_long = state, state = strayr::strayr(state_long), pop = as.numeric(value), year = as.factor(glue::glue(&quot;y{year}&quot;))) %&gt;% filter(year %in% c(&quot;y2013&quot;, &quot;y2018&quot;), data_item == &quot;Persons - Total (no.)&quot;, sa4_name != &quot;Other Territories&quot;) %&gt;% group_by(year, state, sa4_name) %&gt;% summarise(pop = sum(pop)) %&gt;% spread(year, pop) %&gt;% mutate(pop_change = 100 * (y2018 / y2013 - 1)) population_diff %&gt;% ggplot(aes(x = y2013/1000, y = pop_change)) + geom_point(size = 4) + theme_grattan() + theme(axis.title.y = element_text(angle = 90)) + grattan_y_continuous() + labs(y = &quot;Population increase to 2018, per cent&quot;, x = &quot;Population in 2013, thousands&quot;) It looks like the areas with the largest population grew the most between 2013 and 2018. To explore the relationship further, you can add a line-of-best-fit with geom_smooth: population_diff %&gt;% ggplot(aes(x = y2013/1000, # display the x-axis as thousands y = pop_change)) + geom_point(size = 4) + geom_smooth() + geom_hline(yintercept = 0) + theme_grattan() + theme(axis.title.y = element_text(angle = 90)) + grattan_y_continuous() + labs(y = &quot;Population increase to 2018, per cent&quot;, x = &quot;Population in 2013, thousands&quot;) You could colour-code positive and negative changes from within the geom_point aesthetic. Making a change there won’t pass through to the geom_smooth aesthetic, so your line-of-best-fit will apply to all data points. population_diff %&gt;% ggplot(aes(x = y2013/1000, # display the x-axis as thousands y = pop_change)) + geom_point(aes(colour = pop_change &lt; 0), size = 4) + geom_smooth() + geom_hline(yintercept = 0) + theme_grattan() + theme(axis.title.y = element_text(angle = 90)) + grattan_y_continuous() + grattan_colour_manual(2) + labs(y = &quot;Population increase to 2018, per cent&quot;, x = &quot;Population in 2013, thousands&quot;) Like the charts above, you could facet this by state to see if there were any interesting patterns. We’ll filter out ACT and NT because they only have one and two data points (SA4s) in them, respectively. population_diff %&gt;% filter(state != &quot;ACT&quot;, state != &quot;NT&quot;) %&gt;% ggplot(aes(x = y2013/1000, # display the x-axis as thousands y = pop_change)) + geom_point(aes(colour = pop_change &lt; 0), size = 2) + geom_smooth() + geom_hline(yintercept = 0) + theme_grattan() + theme(axis.title.y = element_text(angle = 90)) + grattan_y_continuous() + grattan_colour_manual(2) + labs(y = &quot;Population increase to 2018, per cent&quot;, x = &quot;Population in 2013, thousands&quot;) + facet_wrap(state ~ .) 2.4.4 Distributions geom_histogram geom_density ggridges:: 2.4.5 Maps 2.4.6 sf objects [what is] 2.4.7 Using absmapsdata The absmapsdata contains compressed, and tidied sf objects containing geometric information about ABS data structures. The included objects are: Statistical Area 1 2011: sa12011 Statistical Area 1 2016: sa12016 Statistical Area 2 2011: sa22011 Statistical Area 2 2016: sa22016 Statistical Area 3 2011: sa32011 Statistical Area 3 2016: sa32016 Statistical Area 4 2011: sa42011 Statistical Area 4 2016: sa42016 Greater Capital Cities 2011: gcc2011 Greater Capital Cities 2016: gcc2016 Remoteness Areas 2011: ra2011 Remoteness Areas 2016: ra2016 State 2011: state2011 State 2016: state2016 Commonwealth Electoral Divisions 2018: ced2018 State Electoral Divisions 2018:sed2018 Local Government Areas 2016: lga2016 Local Government Areas 2018: lga2018 You can install the package from Github. You will also need the sf package installed to handle the sf objects. devtools::install_github(&quot;wfmackey/absmapsdata&quot;) library(absmapsdata) install.packages(&quot;sf&quot;) library(sf) 2.4.7.1 Making choropleth maps Choropleth maps break an area into ‘bits’, and colours each ‘bit’ according to a variable. SA4 is the largest non-state statistical area in the ABS ASGS standard. You can join the sf objects from absmapsdata to your dataset using left_join. The variable names might be different – eg sa4_name compared to sa4_name_2016 – so use the by function to match them. map_data &lt;- population_diff %&gt;% left_join(sa42016, by = c(&quot;sa4_name&quot; = &quot;sa4_name_2016&quot;)) head(map_data %&gt;% select(sa4_name, geometry)) ## # A tibble: 6 x 3 ## # Groups: state [2] ## state sa4_name geometry ## &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [°]&gt; ## 1 ACT Australian Capita… (((148.8041 -35.71402, 148.8018 -35.7121, 148.7… ## 2 NSW Capital Region (((150.3113 -35.66588, 150.3126 -35.66814, 150.… ## 3 NSW Central Coast (((151.315 -33.55582, 151.3159 -33.55503, 151.3… ## 4 NSW Central West (((150.6107 -33.06614, 150.6117 -33.07051, 150.… ## 5 NSW Coffs Harbour - G… (((153.2785 -29.91874, 153.2773 -29.92067, 153.… ## 6 NSW Far West and Orana (((150.1106 -31.74613, 150.1103 -31.74892, 150.… You then plot a map like you would any other ggplot: provide your data, choose your aes and your geom. For maps with sf objects, the key aesthetic is geometry = geometry, and the geom is geom_sf. map &lt;- map_data %&gt;% ggplot(aes(geometry = geometry, fill = pop_change)) + geom_sf(lwd = 0) + theme_void() + grattan_fill_manual(discrete = FALSE, palette = &quot;diverging&quot;, limits = c(-20, 20), breaks = seq(-20, 20, 5)) + labs(fill = &quot;Population change&quot;) map 2.5 Creating simple interactive graphs with plotly plotly::ggplotly() 2.6 bin: generate data used (before prior sections are constructed) library(tidyverse) library(janitor) library(absmapsdata) data &lt;- read_csv(&quot;data/ABS_REGIONAL_ASGS2016_02082019164509969.csv&quot;) %&gt;% clean_names() %&gt;% select(data_code = measure, data_item, asgs = regiontype, sa4_code_2016 = asgs_2016, sa4_name_2016 = region, year = time, value) %&gt;% mutate(sa4_code_2016 = as.character(sa4_code_2016)) %&gt;% left_join(sa42016 %&gt;% select(sa4_code_2016, state_name_2016)) %&gt;% rename(state = state_name_2016, sa4_code = sa4_code_2016, sa4_name = sa4_name_2016) write_csv(data, &quot;data/population_sa4.csv&quot;) "],
["reading-data.html", "3 Reading data 3.1 Importing data 3.2 Reading common files: 3.3 Appropriately renaming variables 3.4 Getting to tidy data", " 3 Reading data 3.1 Importing data 3.1.1 Reading CSV files 3.1.1.1 read_csv() The read_csv() function from the tidyverse is quicker and smarter than read.csv in base R. Pitfalls: 1. read_csv is quicker because it surveys a sample of the data We can also compress .csv files into .zip files and read them directly using read_csv(): read_csv(&quot;data/my_data.zip&quot;) This is useful for two reasons: The data takes up less room on your computer; and The original data, which shouldn’t ever be directly edited, is protected and cannot be directly edited. 3.1.1.2 data.table::fread() The fread function from data.table is quicker than both read.csv and read_csv. 3.1.2 readxl::read_excel() 3.1.3 rio 3.1.4 readabs 3.2 Reading common files: TableBuilder CSVSTRINGs HES household file SIH LSAY and derivatives See data directory for a list of microdata available to Grattan. 3.3 Appropriately renaming variables As shown in the style guide Add rename_abs function to a common Grattan package? 3.4 Getting to tidy data pivot_long() and pivot_wide() Make sure these are stable btw "],
["different-data-types.html", "4 Different data types 4.1 Tidy data 4.2 Dates with lubridate:: 4.3 Strings with stringr:: 4.4 Factors with forcats::", " 4 Different data types 4.1 Tidy data Other data structures 4.2 Dates with lubridate:: The lubridate:: package 4.3 Strings with stringr:: Replacing values Matching values Separating columns 4.4 Factors with forcats:: Dangers with factors "],
["data-transformation.html", "5 Data transformation 5.1 The pipe 5.2 Key dplyr functions: 5.3 Filter with filter() 5.4 Arrange with arrange() 5.5 Select variables with select() 5.6 Group data with group_by() 5.7 Edit and add new variables with mutate() 5.8 Summarise data with summarise() 5.9 Joining datasets with *_join()", " 5 Data transformation 5.1 The pipe 5.2 Key dplyr functions: All have the same syntax structure, which enable pipe-chains. 5.3 Filter with filter() 5.4 Arrange with arrange() 5.5 Select variables with select() 5.6 Group data with group_by() 5.7 Edit and add new variables with mutate() 5.7.1 Cases when you should use case_when() 5.8 Summarise data with summarise() 5.9 Joining datasets with *_join() "],
["analysis.html", "6 Analysis", " 6 Analysis "],
["creating-functions.html", "7 Creating functions 7.1 It can be useful to make your own function 7.2 Defining simple functions 7.3 More complex functions 7.4 Sets of functions 7.5 Using purrr::map 7.6 Sharing your useful functions with Grattan", " 7 Creating functions 7.1 It can be useful to make your own function Why on earth would you create your own function? 7.2 Defining simple functions 7.3 More complex functions 7.4 Sets of functions 7.5 Using purrr::map 7.6 Sharing your useful functions with Grattan "],
["version-control.html", "8 Version control 8.1 Version control is important and intimidating 8.2 Github 8.3 Git", " 8 Version control 8.1 Version control is important and intimidating Version control is great! 8.2 Github We use Github to version-control and share reports in LaTeX, so you’re already a bit set-up. 8.3 Git Using Git within R Studio… "],
["references.html", "References", " References "]
]
