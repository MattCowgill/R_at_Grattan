[
["coding-style.html", "4 Grattan coding style 4.1 Load packages first 4.2 Script preamble 4.3 Use comments 4.4 Breaking your script into chunks 4.5 Assigning values to objects 4.6 Naming objects and variables 4.7 Spacing 4.8 Short lines, line indentation and the pipe %&gt;% 4.9 Omit needless code", " 4 Grattan coding style This page sets out the core elements of coding style we use at Grattan. If you’re new to R, don’t stress about remembering - or even understanding - everything on this page. Just be aware that we have a coding style, and come back to this when you’re a bit further along. The benefits of a common coding style are well explained by Hadley Wickham: Good style is important because while your code only has one author, it’ll usually have multiple readers. This is especially true when you’re writing code with others. In that case, it’s a good idea to agree on a common style up-front. Below we describe the key elements of Grattan coding style, without being too tedious about it all. There are many elements of coding style we don’t cover in this guide; if you’re unsure about anything, consult the tidyverse guide. You should also see the Using R at Grattan page for guidelines about setting up projects. 4.1 Load packages first Our analysis scripts will almost always involve loading some packages. These should be laoded at the top of a script, in one block like this: library(tidyverse) library(grattantheme) If you’re loading a package from Github, it’s a good idea to leave a comment to say where it came from, like this: library(tidyverse) library(grattantheme) library(strayr) # remotes::install_github(&quot;mattcowgill/strayr&quot;) Don’t scatter library() calls throughout your script - put them all at the top. The only thing that should come before loading your packages is the script preamble. 4.2 Script preamble Describe what your script does in the first few lines using comments or within an RMarkdown document. Good # This script reads ABS data downloaded from TableBuilder and combines into a single data object containing post-secondary education levels by age and gender by SA3. Your preamble might also pose a research question that the script will answer. Good # Do women have higher levels of educational attainment than men, within the same geographical areas and age groups? Your preamble shouldn’t be a terse, inscrutable comment. Bad # make ABS ed data graph If it’s hard to concisely describe what your script does in a few lines of plain English, that might be a sign that your script does too many things. Consider breaking your analysis into a series of scripts. See Organising R Projects at Grattan for more. Your preamble should anticipate and answer any questions other people might have when reviewing your script. For example: Good # This script calculates average income by age group and sex using the ABS Household Expenditure Survey and joins this to health information by age groups and sex from the National Health Survey. Note that we can&#39;t use the income variable in the NHS for this purpose, as it only contains information about respondents&#39; income decile, not the income itself. The preamble should pertain the the code contained in the specific script. If you have comments or information about your analysis as a whole, put it in your README file. 4.3 Use comments Comments are necessary where the code alone doesn’t tell the full story. Comments should tell the reader why you’re doing something, rather than just what you’re doing. For example, comments are important when groups are coded with numbers rather than character strings, because this might not be obvious to someone reading your script: Necessary to comment data %&gt;% filter(gender == 1, # Keep only male observations age == &quot;05&quot;) # Keep only 35-39 year-olds. Without the comment, readers of your code might not be aware that 1 in this dataset corresponds to male, or that age == \"05\" refers to 35-39 year olds. Without the comment, the code is not self-explanatory. If your code is self-explanatory, you can include or omit comments as you see fit. Not necessary (but okay if included) # We want to only look at women aged 35-39 data %&gt;% filter(gender == &quot;Female&quot;, age &gt;= 35 &amp; age &lt;= 39) You should also include comments where your code is more complex and may not be easily understood by the reader. If you’re using a function from a package that isn’t commonly used at Grattan, include a comment to explain what it does. Err on the side of commenting more, rather than less, throughout your code. Something may seem obvious to you when you’re writing your code, but it might not be obvious to the person reading your code, even if that person is you in the future. Better to over-comment than under-comment. Comments can go above code chunks, or next to code - there are examples of both above. 4.4 Breaking your script into chunks It’s useful to break a lengthy script into chunks with -----. Good # Read file A ----- a &lt;- read_csv(&quot;data/a.csv&quot;) # Read file B ----- b &lt;- read_csv(&quot;data/b.csv&quot;) # Combine files A and B ---- c &lt;- bind_rows(a, b) This helps you, and others, navigate your code better, using the navigation tool built in to RStudio. In the script editor pane of RStudio, at the bottom left, there’s a little navigation tool that helps you easily jump between named sections of your script. Breaking your script into chunks with ----- also makes your code easier to read. 4.5 Assigning values to objects In R, you work with objects. An object might be a data frame, or a vector of numbers or letters, or a list. Functions can be objects, too. Use the &lt;- operator to assign values to objects. Here are some good examples: schools &lt;- read_csv(&quot;data/schools_data.csv&quot;) three_letters &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) lf &lt;- labour_force %&gt;% filter(status != &quot;NILF&quot;) Avoid -&gt;, = and assign(). Here are some bad examples:: schools = read_csv(&quot;data/schools_data.csv&quot;) assign(&quot;three_letters&quot;, c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;)) labour_force %&gt;% filter(status != &quot;NILF&quot;) -&gt; lf All these bad operators will work, but they are best avoided. The = operator is avoided for reasons of visual consistency, style, and to avoid confusion. assign() is avoided because it can lead to unexpected behaviour, and is usually not the best way to do what you want to do. The -&gt; operator is avoided because it’s easy to miss when skimming over code. The &lt;&lt;- operator should also be avoided. 4.6 Naming objects and variables It’s important to be consistent when naming things. This saves you time when writing code. If you use a consistent naming convention, you don’t need to stop to remember if your object is called ed_by_age or edByAge or ed.by.age. Having a consistent naming convention across Grattan also makes it easy to read and QC each other’s code. Grattan primarily uses words separated by underscores _ (aka ‘snake_case’) to name objects and variables. This is considered good practice across the Tidyverse. Object names should be descriptive and not-too-long. This is a trade-off, and one that’s sometimes hard to get right. However, using snake_case provides consistency: Good object names sa3_population gdp_growth_vic uni_attainment Bad object names sa3Pop GDPgrowthVIC uni.attainment Variable names face a similar trade-off. Again, try to be descriptive and short using snake_case: Good variable names gender gdp_growth highest_edu Bad variable names s801LHSAA gdp.growth highEdu chaosVar_name.silly var2 When you load data from outside Grattan, such as ABS microdata, variables will often have bad names. It is worth taking the time at the top of your script to rename your variables, giving them consistent, descriptive, short, snake_case names. The most important thing is that your code is internally consistent - you should stick to one naming convention for all your objects and variables. Using snake_case, which we strongly recommend, reduces friction for other people reading and editing your code. Using short names saves effort when coding. Using descriptive names makes your code easier to read and understand. 4.7 Spacing Giving your code room to breathe greatly helps readability for future-you and others who will have to read your code. Code without ample whitespace is hard to read, justasitishardertoreadEnglishsentenceswithoutspaces. 4.7.1 Assign and equals Put a space each side of an assign operator &lt;-, equals =, and other ‘infix operators’ (==, +, -, and so on). Good uni_attainment &lt;- filter(data, age == 25, gender == &quot;Female&quot;) Bad uni_attainment&lt;-filter(data,age==25,gender==&quot;Female&quot;) Exceptions are operators that directly connect to an object, package or function, which should not have spaces on either side: ::, $, @, [, [[, etc. Good uni_attainment$gender uni_attainment$age[1:10] readabs::read_abs() Bad uni_attainment $ gender uni_attainment$ age [ 1 : 10] readabs :: read_abs() 4.7.2 Commas Always put a space after a comma and not before, just like in regular English. Good select(data, age, gender, sa2, sa3) Bad select(data,age,gender,sa2,sa3) 4.7.3 Parentheses Do not use spaces around parentheses in most cases: Good mean(x, na.rm = TRUE) Bad mean (x, na.rm = TRUE) mean( x, na.rm = TRUE ) For spacing rules around if, for, while, and function, see the Tidyverse guide. 4.8 Short lines, line indentation and the pipe %&gt;% It’s tedious – yes – but short lines and consistent line indentation can help make reading code much easier. If you are supplying multiple arguments to a function, it’s generally a good idea to put each argument on a new line - hit return after the comma, like in the rename and filter examples below. Indentation makes it clear where a code block starts and finishes. Using pipes (%&gt;%) instead of nesting functions also makes things clearer.1 The pipe should always have a space before it, and should generally be followed by a new line, as in this example: Good: short lines and indentation young_qual_income &lt;- data %&gt;% rename(gender = s801LHSAA, uni_attainment = high.ed) %&gt;% filter(income &gt; 0, age &gt;= 25 &amp; age &lt;= 34) %&gt;% group_by(gender, uni_attainment) %&gt;% summarise(mean_income = mean(income, na.rm = TRUE)) Without indentation, the code is harder to read. It’s not clear where the chunk starts and finishes, and which bits of code are arguments to which functions. Bad: short lines, no indentation young_qual_income &lt;- data %&gt;% rename(gender = s801LHSAA, uni_attainment = high.ed) %&gt;% filter(income &gt; 0, age &gt;= 25 &amp; age &lt;= 34) %&gt;% group_by(gender, uni_attainment) %&gt;% summarise(mean_income = mean(income, na.rm = TRUE)) Long lines are also bad and hard to read. Bad: long lines young_qual_income &lt;- data %&gt;% rename(gender = s801LHSAA, uni_attainment = high.ed) %&gt;% filter(income &gt; 0, age &gt;= 25 &amp; age &lt;= 34) %&gt;% group_by(gender, uni_attainment) %&gt;% summarise(mean_income = mean(income, na.rm = TRUE)) When you want to take the output of a function and pass it as the input to another function, use the pipe (%&gt;%). Don’t write ugly, inscrutable code like this, where multiple functions are wrapped around other functions. War-crime bad: long lines without pipes young_qual_income&lt;-summarise(group_by(filter(rename(data,gender=s801LHSAA,uni_attainment=high.ed),income&gt;0,age&gt;=25&amp;age&lt;=34),uni_attainment),mean_income=mean(income,na.rm=TRUE)) Writing clear code chunks, where functions are strung together with a pipe (%&gt;%), makes your code much more expressive and able to be read and understood. This is another reason to favour R over something like Excel, which pushes people to piece together functions into Frankenstein’s monsters like this: =IF($G16 = &quot;All day&quot;, INDEX(metrics!$D$8:$H$66, MATCH(INDEX(correspondence!$B$2:$B$23, MATCH(&#39;convert to tibble&#39;!M$4, correspondence!$A$2:$A$23, 0)), metrics!$B$8:$B$66, 0), MATCH(&#39;convert to tibble&#39;!$E16, metrics!$D$4:$H$4, 0)), &quot;NA&quot;) I just threw up in my mouth a little bit. The pipe function %&gt;% can make code more easy to write and read. The pipe can create the temptation to string together lots and lots of functions into one block of code. This can make things harder to read and understand. Resist the urge to use the pipe to make code blocks too long. A block of code should generally do one thing, or a small number of things. 4.9 Omit needless code Don’t retain code that ultimately didn’t lead anywhere. If you produced a graph that ended up not being used, don’t keep the code in your script - if you want to save it, move it to a subfolder named ‘archive’ or similar. Your code should include the steps needed to go from your raw data to your output - and not extraneous steps. If you ask someone to QC your work, they shouldn’t have to wade through 1000 lines of code just to find the 200 lines that are actually required to produce your output. When you’re doing data analysis, you’ll often give R interactive commands to help you understand what your data looks like. For example, you might view a dataframe with View(mydf) or str(mydf). This is fine, and often necessary, when you’re doing your analysis. Don’t keep these commands in your script. These type of commands should usually be entered straight into the R console, not in a script. If they’re in your script, delete them. The pipe is from the magrittr package and is used to chain functions together, so that the output from one function becomes the input to the next function. The pipe is loaded as part of the tidyverse.↩ "]
]
