[
["data-visualisation.html", "4 Data Visualisation 4.1 Introduction to data visualisation 4.2 Set-up and packages 4.3 Concepts 4.4 Exploratory data visualisation 4.5 Making Grattan-y charts 4.6 Adding labels 4.7 Chart cookbook 4.8 Creating simple interactive graphs with plotly 4.9 bin: generate data used (before prior sections are constructed)", " 4 Data Visualisation This chapter explores 4.1 Introduction to data visualisation Data visualisation is used in two broad ways: to examine and explore your data; and to present a finding to your audience. When you start using a dataset, you should look at it.1 Plot histograms of variables-of-interest to spot outliers. Explore correlations with scatter plots and lines-of-best-fit. Check how many observations are in particular groups with bar charts. Identify variables that have missing or coded-missing values. Use faceting to explore differences in the above between groups, and do it interactively with non-static plots. These exploratory plots are just for you and your team. They don’t need to be perfectly labelled, the right size, in the Grattan palette or be particularly interesting. They’re built and used to explore the data. Through this process, you can become confident your data is what it says it is. When you present a visualisation to a reader, you make decisions about what they can and cannot see. You choose to highlight or omit particular things to help them better understand the message you are presenting. This requires important technical decisions: what data to use, what ‘stat’ to present it with — show every data point, show a distribution function, show the average or the median — and on what scale — raw numbers, on a log scale, as a proportion of a total. It also requires aesthetic decisions. What colours in the Grattan palette would work best? Where should the labels be placed and how could they be phrased to succinctly convey meaning? Should data points be represented by lines, or bars, or dots, or balloons, or shades of colour? All of these decisions need to made with two things in mind: Rigour, accuracy, legitimacy: the chart needs to be honest. The reader: the chart needs to help the reader understand something, and it must convince them to pay attention. At the margins, sometimes these two ideas can be in conflict: maybe a 70-word definition in the middle of your chart would improve its technical accuracy, but it could confuse the average reader. Similarly, a bar chart is often the safest way to display data. But if the reader has stopped paying attention by your sixth consecutive bar chart, your point loses its punch.2 The way we design charts – much like our writing – should always be honest, clear and engaging to the reader. This chapter shows how you can do this with R. It starts with the ‘grammar of graphics’ concepts of a package called ggplot, explains how to make those charts ‘Grattan-y’, then provides examples for all common (and some not-so-common) charts you should add to your box of data visualisation tools to impress your message on our readers. 4.2 Set-up and packages This section uses the package ggplot2 to visualise data, and dplyr functions to manipulate data. Both of these packages are loaded with tidyverse. The scales package helps with labelling your axes. The grattantheme package is used to make charts look Grattan-y. The absmapsdata package is used to help make maps. library(tidyverse) library(grattantheme) library(ggrepel) library(absmapsdata) library(sf) library(scales) For most charts in this chapter, we’ll use the population_table data summarised here. It contains the population in each state between 2013 and 2018: population_table &lt;- read_csv(&quot;data/population_sa4.csv&quot;) %&gt;% filter(data_item == &quot;Persons - Total (no.)&quot;) %&gt;% mutate(pop = as.numeric(value), year = as.factor(year)) %&gt;% group_by(year, state) %&gt;% summarise(pop = sum(pop)) %&gt;% mutate(state_long = state, state = strayr::strayr(state_long)) # Show the first six rows of the new dataset head(population_table) ## # A tibble: 6 x 4 ## # Groups: year [1] ## year state pop state_long ## &lt;fct&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 2013 ACT 383257 Australian Capital Territory ## 2 2013 NSW 7404032 New South Wales ## 3 2013 NT 241722 Northern Territory ## 4 2013 NT 2962 Other Territories ## 5 2013 Qld 4652824 Queensland ## 6 2013 SA 1671488 South Australia 4.3 Concepts The ggplot2 package is based on the grammar of graphics. … The main ingredients to a ggplot chart are: Data: what data should be plotted. e.g. data Aesthetics: what variables should be linked to what chart elements. e.g. aes(x = population, y = age) to connect the population variable to the x axis, and the age variable to the y axis. Geoms: how the data should be plotted. e.g. geom_point() will produce a scatter plot, geom_col will produce a column chart, geom_line() will produce a line chart. Each plot you make will be made up of these three elements. The full list of standard geoms is listed in the tidyverse documentation. ggplot also has a ‘cheat sheet’ that contains many of the often-used elements of a plot, which you can download here. For example, you can plot a column chart by passing the population_table dataset into ggplot() (“make a chart with this data”). This completes the first step – data – and produces an empty plot: population_table %&gt;% ggplot() Next, set the aes (aesthetics) to x = state (“make the x-axis represent state”), y = pop (“the y-axis should represent population”), and fill = year (“the fill colour represents year”). Now ggplot knows where things should go. If we just plot that, you’ll see that ggplot knows a little bit more about what we’re trying to do. It has the states on the x-axis and range of populations on the y-axis: population_table %&gt;% ggplot(aes(x = state, y = pop, fill = year)) Now that ggplot knows where things should go, it needs to how to plot them on the chart. For this we use geoms. Tell ggplot to take the things it knows and plot them as a column chart by using geom_col: population_table %&gt;% ggplot(aes(x = state, y = pop, fill = year)) + geom_col() Great! Although stacking populations is a bit silly. You can adjust the way a geom works with arguments. In this case, tell geom_col to place the different categories next to each other rather than on-top of each other, using position = &quot;dodge&quot;: population_table %&gt;% ggplot(aes(x = state, y = pop, fill = year)) + geom_col(position = &quot;dodge&quot;) That makes more sense. The following sections in this chapter will cover a broad range of charts and designs, but they will all use the same building-blocks of data, aes, and geom. The rest of the chapter will explore: Exploratory data visualisation Grattanising your charts and choosing colours Saving charts according to Grattan templates Making bar, line, scatter and distribution plots Making maps and interactive charts Adding chart labels 4.4 Exploratory data visualisation Plotting your data early in the analysis stage can help you quickly identify outliers, oddities, things that don’t look quite right. 4.5 Making Grattan-y charts The grattantheme package contains functions that help Grattanise your charts. It is hosted here: https://github.com/mattcowgill/grattantheme You can install it with remotes::install_github from the package: install.packages(&quot;remotes&quot;) remotes::install_github(&quot;mattcowgill/grattantheme&quot;) The key functions of grattantheme are: theme_grattan: set size, font and colour defaults that adhere to the Grattan style guide. grattan_y_continuous: sets the right defaults for a continuous y-axis. grattan_colour_continuous: pulls colours from the Grattan colour palette for colour aesthetics. grattan_fill_continuous: pulls colours from the Grattan colour palette for fill aesthetics. grattan_save: a save function that exports charts in correct report or presentation dimensions. This section will run through some examples of Grattanising charts. The ggplot functions are explored in more detail in the next section. 4.5.1 Making Grattan charts Start with a column chart, similar to the one made above: base_chart &lt;- population_table %&gt;% ggplot(aes(x = state, y = pop, fill = year)) + geom_col(position = &quot;dodge&quot;) + labs(x = &quot;&quot;, title = &quot;NSW and Victoria are booming&quot;, subtitle = &quot;Population by state, 2013-2018&quot;, caption = &quot;Source: ABS Regional Dataset (2019)&quot;) base_chart Let’s make it Grattany. First, add theme_grattan to your plot: base_chart + theme_grattan() Then grattan_y_continuous to align the x-axis with zero. This function takes the same arguments as scale_y_continuous, so you can add labels = comma() to reformat the y-axis labels: base_chart + theme_grattan() + grattan_y_continuous(labels = comma) To define fill colours, use grattan_fill_manual with the number of colours you need (six, in this case): pop_chart &lt;- base_chart + theme_grattan() + grattan_y_continuous(labels = comma) + grattan_fill_manual(6) pop_chart Nice chart! Now you can save it and share it with the world. 4.5.2 Saving Grattan charts The grattan_save function saves your charts according to Grattan templates. It takes these arguments: filename: the path, name and file-type of your saved chart. eg: &quot;atlas/population_chart.pdf&quot;. object: the R object that you want to save. eg: pop_chart. If left blank, it grabs the last chart that was displayed. type: the Grattan template to be used. This is one of: &quot;normal&quot; The default. Use for normal Grattan report charts, or to paste into a 4:3 PowerPoint slide. Width: 22.2cm, height: 14.5cm. &quot;normal_169&quot; Only useful for pasting into a 16:9 format Grattan PowerPoint slide. Width: 30cm, height: 14.5cm. &quot;tiny&quot; Fills the width of a column in a Grattan report, but is shorter than usual. Width: 22.2cm, height: 11.1cm. &quot;wholecolumn&quot; Takes up a whole column in a Grattan report. Width: 22.2cm, height: 22.2cm. &quot;fullpage&quot; Fills a whole page of a Grattan report. Width: 44.3cm, height: 22.2cm. &quot;fullslide&quot; Creates an image that looks like a 4:3 Grattan PowerPoint slide, complete with logo. Width: 25.4cm, height: 19.0cm. &quot;fullslide_169&quot; Creates` an image that looks like a 16:9 Grattan PowerPoint slide, complete with logo. Use this to drop into standard presentations. Width: 33.9cm, height: 19.0cm &quot;blog&quot; Creates a 4:3 image that looks like a Grattan PowerPoint slide, but with less border whitespace than ‘fullslide’.&quot; &quot;fullslide_44&quot; Creates an image that looks like a 4:4 Grattan PowerPoint slide. This may be useful for taller charts for the Grattan blog; not useful for any other purpose. Width: 25.4cm, height: 25.4cm. Set type = &quot;all&quot; to save your chart in all available sizes. height: override the height set by type. This can be useful for really long charts in blogposts. save_data: exports a csv file containing the data used in the chart. force_labs: override the removal of labels for a particular type. eg force_labs = TRUE will keep the y-axis label. To save the pop_chart plot created above as a whole-column chart for a report: grattan_save(&quot;atlas/population_chart_report.pdf&quot;, pop_chart, type = &quot;wholecolumn&quot;) To save it as a presentation slide instead, use type = &quot;fullslide&quot;: grattan_save(&quot;atlas/population_chart_presentation.pdf&quot;, pop_chart, type = &quot;fullslide&quot;) Or, if you want to emphasise the point in a really tall chart for a blogpost, you can use type = &quot;blog&quot; and adjust the height to be 50cm. Also note that because this is for the blog, you should save it as a png file: grattan_save(&quot;atlas/population_chart_blog.png&quot;, pop_chart, type = &quot;blog&quot;, height = 50) And that’s it! The following sections will go into more detail about different chart types in R, but you’ll mostly use the same basic grattantheme formatting you’ve used here. 4.6 Adding labels Labels can be a bit finicky – especially compared to labelling charts visually in PowerPoint. … Labels can be done in two broad ways: As a single plot of text on the chart: the command annotate takes some text and plots it at the coordinates you specifiy. As data, using aesthetics: geom_label and geom_text (and some useful extensions) fit into this group. They take aesthetics from a dataframe and plot text on the chart according to those rules. annotate works well if you want to add a note to your chart. You specify the geom type, &quot;text&quot;, and the x and y coordinates: &quot;Vic&quot; and 7.2e6 (7.2*10^6, 7.2 million). Then set the size, colour, and horizontal alignment with hjust (0 is left-aligned, 0.5 is centered, 1 is right-aligned). Add your text with label, and you’re done. base_chart + theme_grattan() + grattan_y_continuous(labels = comma) + grattan_fill_manual(6) + annotate(&quot;text&quot;, x = &quot;Vic&quot;, y = 7.2e6, size = 12/.pt, colour = grattan_grey3, hjust = 1, label = &quot;Victoria has had\\nsubstantial\\ngrowth&quot;) we can use geom_label to add labels to our chart. This is one of many tools you can use to label your chart, which will be explored throughout the CHARTK BOOK SECTION. is best when you want to add a single label to a chart: labels &lt;- population_table %&gt;% filter(state == &quot;Qld&quot;) pop_chart &lt;- base_chart + theme_grattan() + grattan_y_continuous(labels = comma) + grattan_fill_manual(6) + geom_text(data = labels, aes(label = year, colour = ), size = 16/.pt, position = position_dodge(width = 1), angle = 90, hjust = -.25, vjust = 0.5) + grattan_colour_manual(6) pop_chart 4.7 Chart cookbook This section takes you through a few often-used chart types. 4.7.1 Bar charts Bar charts are made with geom_bar or geom_col. Creating a bar chart will look something like this: ggplot(data = &lt;data&gt;) + geom_bar(aes(x = &lt;xvar&gt;, y = &lt;yvar&gt;), stat = &lt;STAT&gt;, position = &lt;POSITION&gt; ) It has two key arguments: stat and position. First, stat defines what kind of operation the function will do on the dataset before plotting. Some options are: &quot;count&quot;, the default: count the number of observations in a particular group, and plot that number. This is useful when you’re using microdata. When this is the case, there is no need for a y aesthetic. &quot;sum&quot;: sum the values of the y aesthetic. &quot;identity&quot;: directly report the values of the y aesthetic. This is how PowerPoint and Excel charts work. You can use geom_col instead, as a shortcut for geom_bar(stat = &quot;identity). Second, position, dictates how multiple bars occupying the same x-axis position will positioned. The options are: &quot;stack&quot;, the default: bars in the same group are stacked atop one another. &quot;dodge&quot;: bars in the same group are positioned next to one another. &quot;fill&quot;: bars in the same group are stacked and all fill to 100 per cent. population_table %&gt;% ggplot(aes(x = state, y = pop, fill = year)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + theme_grattan() + grattan_y_continuous(labels = comma) + grattan_fill_manual(6) + labs(x = &quot;&quot;, y = &quot;&quot;) You can also order the groups in your chart by a variable. If you want to order states by population, use reorder inside aes: population_table %&gt;% ggplot(aes(x = reorder(state, -pop), # reorder state by negative population y = pop, fill = year)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + theme_grattan() + grattan_y_continuous(labels = comma) + grattan_fill_manual(6) + labs(x = &quot;&quot;, y = &quot;&quot;) To flip the chart – a useful move when you have long labels – add coord_flipped (ie ‘flip coordinates’) and tell theme_grattan that the plot is flipped using flipped = TRUE. population_table %&gt;% ggplot(aes(x = reorder(state, -pop), y = pop, fill = year)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + coord_flip() + # flip the coordinates theme_grattan(flipped = TRUE) + # tell theme_grattan grattan_y_continuous(labels = comma) + grattan_fill_manual(6) + labs(x = &quot;&quot;, y = &quot;&quot;) Our long numeric labels means the chart clips them off a bit at the end. We can deal with this in two ways: Adjust the limits of the axis to accommodate the long labels, meaning we will have to define our own axis-label breaks using the seq function3: population_table %&gt;% ggplot(aes(x = reorder(state, -pop), y = pop, fill = year)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + coord_flip() + theme_grattan(flipped = TRUE) + grattan_y_continuous(labels = comma, limits = c(0, 9e6), breaks = seq(0, 8e6, 2e6)) + grattan_fill_manual(6) + labs(x = &quot;&quot;, y = &quot;&quot;) Add empty space at the top of the chart to accommodate the long labels: population_table %&gt;% ggplot(aes(x = reorder(state, -pop), y = pop, fill = year)) + geom_bar(stat = &quot;identity&quot;, position = &quot;dodge&quot;) + coord_flip() + theme_grattan(flipped = TRUE) + grattan_y_continuous(labels = comma, expand_top = .1) + grattan_fill_manual(6) + labs(x = &quot;&quot;, y = &quot;&quot;) 4.7.2 Line charts A line chart has one key aesthetic: group. This tells ggplot how to connect individual lines. population_table %&gt;% ggplot(aes(x = year, y = pop, colour = state, group = state)) + geom_line() + theme_grattan() + grattan_y_continuous(labels = comma) + grattan_colour_manual(9) + labs(x = &quot;&quot;) ## Warning in grattantheme::grattan_pal(n = n, reverse = reverse, faded = ## faded): Using more than six colours is not recommended. You can also add dots for each year by layering geom_point on top of geom_line: population_table %&gt;% ggplot(aes(x = year, y = pop, colour = state, group = state)) + geom_line() + geom_point(size = 2) + theme_grattan() + grattan_y_continuous(labels = comma) + grattan_colour_manual(9) + labs(x = &quot;&quot;, y = &quot;&quot;) ## Warning in grattantheme::grattan_pal(n = n, reverse = reverse, faded = ## faded): Using more than six colours is not recommended. If you wanted to show each state individually, you could facet your chart so that a separate plot was produced for each state: population_table %&gt;% filter(state != &quot;ACT&quot;, state != &quot;NT&quot;) %&gt;% ggplot(aes(x = year, y = pop, group = state)) + geom_line() + geom_point(size = 2) + theme_grattan() + grattan_y_continuous() + facet_wrap(state ~ .) + labs(x = &quot;&quot;) To tidy this up, we can: shorten the years to be “13”, “14”, etc instead of “2013”, “2014”, etc (via the x aesthetic) shorten the y-axis labels to “millions” (via the y aesthetic) add a black horizontal line at the bottom of each facet give the facets a bit of room by adjusting panel.spacing define our own x-axis label breaks to just show 13, 15 and 17 population_table %&gt;% filter(state != &quot;ACT&quot;, state != &quot;NT&quot;) %&gt;% ggplot(aes(x = substr(year, 3, 4), # 1: just take the last two characters y = pop / 1e6, # 2: divide population by one million group = state)) + geom_line() + geom_point(size = 2) + geom_hline(yintercept = 0) + # 3: add horizontal line at the bottom theme_grattan() + theme(panel.spacing = unit(10, &quot;mm&quot;)) + # 4: add panel spacing grattan_y_continuous(labels = comma) + scale_x_discrete(breaks = c(&quot;13&quot;, &quot;15&quot;, &quot;17&quot;)) + # 5: define our own label breaks facet_wrap(state ~ .) + labs(x = &quot;&quot;) 4.7.3 Scatter plots Scatter plots require x and y aesthetics. These can then be coloured and faceted. First, create a dataset that we’ll use for scatter plots. Take the population_table dataset and transform it to have one variable for population in 2013, and another for population in 2018: population_diff &lt;- read_csv(&quot;data/population_sa4.csv&quot;) %&gt;% mutate(state_long = state, state = strayr::strayr(state_long), pop = as.numeric(value), year = as.factor(glue::glue(&quot;y{year}&quot;))) %&gt;% filter(year %in% c(&quot;y2013&quot;, &quot;y2018&quot;), data_item == &quot;Persons - Total (no.)&quot;, sa4_name != &quot;Other Territories&quot;) %&gt;% group_by(year, state, sa4_name) %&gt;% summarise(pop = sum(pop)) %&gt;% spread(year, pop) %&gt;% mutate(pop_change = 100 * (y2018 / y2013 - 1)) Then plot it population_diff %&gt;% ggplot(aes(x = y2013, y = pop_change)) + geom_point(size = 4) + theme_grattan() + theme(axis.title.y = element_text(angle = 90)) + grattan_y_continuous() + labs(y = &quot;Population increase to 2018, per cent&quot;, x = &quot;Population in 2013&quot;) population_diff %&gt;% ggplot(aes(x = y2013/1000, y = pop_change)) + geom_point(size = 4) + theme_grattan() + theme(axis.title.y = element_text(angle = 90)) + grattan_y_continuous() + labs(y = &quot;Population increase to 2018, per cent&quot;, x = &quot;Population in 2013, thousands&quot;) It looks like the areas with the largest population grew the most between 2013 and 2018. To explore the relationship further, you can add a line-of-best-fit with geom_smooth: population_diff %&gt;% ggplot(aes(x = y2013/1000, # display the x-axis as thousands y = pop_change)) + geom_point(size = 4) + geom_smooth() + geom_hline(yintercept = 0) + theme_grattan() + theme(axis.title.y = element_text(angle = 90)) + grattan_y_continuous() + labs(y = &quot;Population increase to 2018, per cent&quot;, x = &quot;Population in 2013, thousands&quot;) You could colour-code positive and negative changes from within the geom_point aesthetic. Making a change there won’t pass through to the geom_smooth aesthetic, so your line-of-best-fit will apply to all data points. population_diff %&gt;% ggplot(aes(x = y2013/1000, # display the x-axis as thousands y = pop_change)) + geom_point(aes(colour = pop_change &lt; 0), size = 4) + geom_smooth() + geom_hline(yintercept = 0) + theme_grattan() + theme(axis.title.y = element_text(angle = 90)) + grattan_y_continuous() + grattan_colour_manual(2) + labs(y = &quot;Population increase to 2018, per cent&quot;, x = &quot;Population in 2013, thousands&quot;) Like the charts above, you could facet this by state to see if there were any interesting patterns. We’ll filter out ACT and NT because they only have one and two data points (SA4s) in them, respectively. population_diff %&gt;% filter(state != &quot;ACT&quot;, state != &quot;NT&quot;) %&gt;% ggplot(aes(x = y2013/1000, # display the x-axis as thousands y = pop_change)) + geom_point(aes(colour = pop_change &lt; 0), size = 2) + geom_smooth() + geom_hline(yintercept = 0) + theme_grattan() + theme(axis.title.y = element_text(angle = 90)) + grattan_y_continuous() + grattan_colour_manual(2) + labs(y = &quot;Population increase to 2018, per cent&quot;, x = &quot;Population in 2013, thousands&quot;) + facet_wrap(state ~ .) 4.7.4 Distributions geom_histogram geom_density ggridges:: 4.7.5 Maps 4.7.5.1 sf objects [what is] 4.7.5.2 Using absmapsdata The absmapsdata contains compressed, and tidied sf objects containing geometric information about ABS data structures. The included objects are: Statistical Area 1 2011 and 2016: sa12011 or sa12016 Statistical Area 2 2011 and 2016: sa22011 or sa22016 Statistical Area 3 2011 and 2016: sa32011 or sa32016 Statistical Area 4 2011 and 2016: sa42011 or sa42016 Greater Capital Cities 2011 and 2016: gcc2011 or gcc2016 Remoteness Areas 2011 and 2016: ra2011 or ra2016 State 2011 and 2016: state2011 or state2016 Commonwealth Electoral Divisions 2018: ced2018 State Electoral Divisions 2018:sed2018 Local Government Areas 2016 and 2018: lga2016 or lga2018 Postcodes 2016: postcodes2016 You can install the package from Github: remotes::install_github(&quot;wfmackey/absmapsdata&quot;) library(absmapsdata) You will also need the sf package installed to handle the sf objects: install.packages(&quot;sf&quot;) library(sf) 4.7.5.3 Making choropleth maps Choropleth maps break an area into ‘bits’, and colours each ‘bit’ according to a variable. SA4 is the largest non-state statistical area in the ABS ASGS standard. You can join the sf objects from absmapsdata to your dataset using left_join. The variable names might be different – eg sa4_name compared to sa4_name_2016 – so use the by function to match them. map_data &lt;- population_diff %&gt;% left_join(sa42016, by = c(&quot;sa4_name&quot; = &quot;sa4_name_2016&quot;)) head(map_data %&gt;% select(sa4_name, geometry)) ## # A tibble: 6 x 3 ## # Groups: state [2] ## state sa4_name geometry ## &lt;chr&gt; &lt;chr&gt; &lt;MULTIPOLYGON [°]&gt; ## 1 ACT Australian Capita… (((148.8041 -35.71402, 148.8018 -35.7121, 148.7… ## 2 NSW Capital Region (((150.3113 -35.66588, 150.3126 -35.66814, 150.… ## 3 NSW Central Coast (((151.315 -33.55582, 151.3159 -33.55503, 151.3… ## 4 NSW Central West (((150.6107 -33.06614, 150.6117 -33.07051, 150.… ## 5 NSW Coffs Harbour - G… (((153.2785 -29.91874, 153.2773 -29.92067, 153.… ## 6 NSW Far West and Orana (((150.1106 -31.74613, 150.1103 -31.74892, 150.… You then plot a map like you would any other ggplot: provide your data, then choose your aes and your geom. For maps with sf objects, the key aesthetic is geometry = geometry, and the key geom is geom_sf. The argument lwd controls the line width of area borders. Note that RStudio takes a long time to render a map in the map &lt;- map_data %&gt;% ggplot(aes(geometry = geometry, fill = pop_change)) + geom_sf(lwd = 0) + theme_void() + grattan_fill_manual(discrete = FALSE, palette = &quot;diverging&quot;, limits = c(-20, 20), breaks = seq(-20, 20, 10)) + labs(fill = &quot;Population \\nchange&quot;) map Showing all of Australia on a single map is difficult: there are enormous areas that are home to few people which dominate the space. Showing individual states or capital city areas can sometimes be useful. To do this, filter the map_data object: map &lt;- map_data %&gt;% filter(state == &quot;Vic&quot;) %&gt;% ggplot(aes(geometry = geometry, fill = pop_change)) + geom_sf(lwd = 0) + theme_void() + grattan_fill_manual(discrete = FALSE, palette = &quot;diverging&quot;, limits = c(-20, 20), breaks = seq(-20, 20, 10)) + labs(fill = &quot;Population \\nchange&quot;) map 4.7.5.3.1 Adding labels to maps You can add labels to choropleth maps with the standard geom_text or geom_label. Because it is likely that some labels will overlap, ggrepel::geom_text_repel or ggrepel::geom_label_repel is usually the better option. To use geom_(text|label)_repel, you need to tell ggrepel where in map &lt;- map_data %&gt;% filter(state == &quot;Vic&quot;) %&gt;% ggplot(aes(geometry = geometry)) + geom_sf(aes(fill = pop_change), lwd = .1, colour = &quot;black&quot;) + theme_void() + grattan_fill_manual(discrete = FALSE, palette = &quot;diverging&quot;, limits = c(-20, 20), breaks = seq(-20, 20, 10)) + geom_label_repel(aes(label = sa4_name), stat = &quot;sf_coordinates&quot;, nudge_x = 1000, segment.alpha = .5, size = 4, direction = &quot;y&quot;, label.size = 0, label.padding = unit(0.1, &quot;lines&quot;), colour = &quot;grey50&quot;, segment.color = &quot;grey50&quot;) + scale_y_continuous(expand = expand_scale(mult = c(0, .2))) + theme(legend.position = &quot;top&quot;) + labs(fill = &quot;Population \\nchange&quot;) map 4.8 Creating simple interactive graphs with plotly plotly::ggplotly() 4.9 bin: generate data used (before prior sections are constructed) library(tidyverse) library(janitor) library(absmapsdata) data &lt;- read_csv(&quot;data/ABS_REGIONAL_ASGS2016_02082019164509969.csv&quot;) %&gt;% clean_names() %&gt;% select(data_code = measure, data_item, asgs = regiontype, sa4_code_2016 = asgs_2016, sa4_name_2016 = region, year = time, value) %&gt;% mutate(sa4_code_2016 = as.character(sa4_code_2016)) %&gt;% left_join(sa42016 %&gt;% select(sa4_code_2016, state_name_2016)) %&gt;% rename(state = state_name_2016, sa4_code = sa4_code_2016, sa4_name = sa4_name_2016) %&gt;% mutate(state_long = state, state = strayr::strayr(state_long)) write_csv(data, &quot;data/population_sa4.csv&quot;) From Kieran Healy’s Data Vizualization: A Practical Introduction) (available free): ‘You should look at your data. Graphs and charts let you explore and learn about the structure of the information you collect. Good data visualizations also make it easier to communicate your ideas and findings to other people.’↩ ‘Bar charts are evidence that you are dead inside’ – Amanda Cox, data editor for the New York Times.↩ seq(x1, x2, y) will return a vector of numbers between x1 and x2, spaced by y. For example: seq(0, 10, 2) will produce 0 2 4 6 8 10↩ "]
]
