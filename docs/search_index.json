[
["data-transformation.html", "8 Data transformation 8.1 Set up 8.2 The pipe: %&gt;% 8.3 Key dplyr functions: 8.4 Select variables with select() 8.5 Filter with filter() 8.6 Arrange with arrange() 8.7 Group data with group_by() 8.8 Edit and add new variables with mutate() 8.9 Summarise data with summarise() 8.10 Joining datasets with *_join()", " 8 Data transformation This section focusses on transforming rectangular datasets. 8.1 Set up library(tidyverse) The sa3_income dataset will be used for all key examples in this chapter.1 It is a long dataset from the ABS that contains the median income and number of workers by Statistical Area 3, occupation and sex between 2010 and 2016. sa3_income &lt;- read_csv(&quot;data/sa3_income.csv&quot;) ## Parsed with column specification: ## cols( ## sa3 = col_double(), ## sa3_name = col_character(), ## sa3_sqkm = col_double(), ## sa3_income_percentile = col_double(), ## sa4_name = col_character(), ## gcc_name = col_character(), ## state = col_character(), ## occupation = col_character(), ## occ_short = col_character(), ## prof = col_character(), ## gender = col_character(), ## year = col_double(), ## median_income = col_double(), ## average_income = col_double(), ## total_income = col_double(), ## workers = col_double() ## ) head(sa3_income) ## # A tibble: 6 x 16 ## sa3 sa3_name sa3_sqkm sa3_income_perc… sa4_name gcc_name state ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 10102 Queanbe… 6511. 80 Capital… Rest of… NSW ## 2 10102 Queanbe… 6511. 76 Capital… Rest of… NSW ## 3 10102 Queanbe… 6511. 78 Capital… Rest of… NSW ## 4 10102 Queanbe… 6511. 76 Capital… Rest of… NSW ## 5 10102 Queanbe… 6511. 74 Capital… Rest of… NSW ## 6 10102 Queanbe… 6511. 79 Capital… Rest of… NSW ## # … with 9 more variables: occupation &lt;chr&gt;, occ_short &lt;chr&gt;, prof &lt;chr&gt;, ## # gender &lt;chr&gt;, year &lt;dbl&gt;, median_income &lt;dbl&gt;, average_income &lt;dbl&gt;, ## # total_income &lt;dbl&gt;, workers &lt;dbl&gt; 8.2 The pipe: %&gt;% You will almost always want to perform more than one of the operations described below on your dataset. One way to perform multiple operations, one after the other, is to ‘nest’ them inside. This nesting will be painfully familiar to Excel users. Consider an example of baking and eating a cake.2 You take the ingredients, combine them, then mix, then bake, and then eat them. In a nested formula, this process looks like: eat(bake(mix(combine(ingredients)))) In a nested formula, you need to start in the middle and work your way out. This means anyone reading your code – including you in the future! – needs to start in the middle and work their way out. But because we’re used to left-right reading, we’re not particularly good at naturally interpreting nested functions like this one. This is where the ‘pipe’ can help. The pipe operator %&gt;% (keyboard shortcut: cmd + shift + m) takes an argument on the left and ‘pipes’ it into the function on the right. Each time you see %&gt;%, you can read it as ‘and then’. So the baking example can then be equivalently expressed as: ingredients %&gt;% combine() %&gt;% mix() %&gt;% bake() %&gt;% eat() Which reads as ‘take the ingredients, then combine, then mix, then bake, then eat them’. This does the same thing as eat(bake(mix(combine(ingredients)))). But it’s much nicer to read, and it’s more natural to write. In simple R code, the function paste takes arguments and combines them together into a single string. So you could use the pipe to: &quot;hello&quot; %&gt;% paste(&quot;dear&quot;, &quot;reader&quot;) ## [1] &quot;hello dear reader&quot; Or you could define a vector of numbers and pass3 them to the sum() function: my_numbers &lt;- c(1, 2, 3, 5, 8, 100) my_numbers %&gt;% sum() ## [1] 119 Or you could skip the intermediate step altogether: c(1, 2, 3, 5, 8, 100) %&gt;% sum() ## [1] 119 The benefits of piping become more clear when you want to perform a few sequential operations on a dataset. For example, you might want to filter the observations in the sa3_income data to only NSW, before you group_by gender and summarise the median_income of these grops (these functions are explained in detail below). All of these functions take ‘data’ as the first argument, and are designed to be used with pipes. Like the income differential it shows, writing this process as a nested function is outrageous and hard to read: summarise((group_by(filter(sa3_income, state == &quot;NSW&quot;), gender)), av_med_income = mean(median_income)) ## # A tibble: 2 x 2 ## gender av_med_income ## &lt;chr&gt; &lt;dbl&gt; ## 1 Men 51340. ## 2 Women 37993. The original common way to avoid this unseemly nesting in R was to assign each ‘step’ its own object, which is definitely clearer: data1 &lt;- filter(sa3_income, state == &quot;NSW&quot;) data2 &lt;- group_by(data1, gender) data3 &lt;- summarise(data2, av_med_income = mean(median_income)) print(data3) ## # A tibble: 2 x 2 ## gender av_med_income ## &lt;chr&gt; &lt;dbl&gt; ## 1 Men 51340. ## 2 Women 37993. And using pipes make the steps clearer still: take the sa3_income data, then %&gt;% filter it to only NSW, then %&gt;% group it by gender, then %&gt;% summarise it sa3_income %&gt;% filter(state == &quot;NSW&quot;) %&gt;% group_by(gender) %&gt;% summarise(av_med_income = mean(median_income)) ## # A tibble: 2 x 2 ## gender av_med_income ## &lt;chr&gt; &lt;dbl&gt; ## 1 Men 51340. ## 2 Women 37993. 8.3 Key dplyr functions: All have the same syntax structure, which enable pipe-chains. 8.4 Select variables with select() The select function takes a dataset and keeps or drops variables (columns) that are specified. For example, look at the variables that are in the sa3_income dataset (using the names() function): names(sa3_income) ## [1] &quot;sa3&quot; &quot;sa3_name&quot; ## [3] &quot;sa3_sqkm&quot; &quot;sa3_income_percentile&quot; ## [5] &quot;sa4_name&quot; &quot;gcc_name&quot; ## [7] &quot;state&quot; &quot;occupation&quot; ## [9] &quot;occ_short&quot; &quot;prof&quot; ## [11] &quot;gender&quot; &quot;year&quot; ## [13] &quot;median_income&quot; &quot;average_income&quot; ## [15] &quot;total_income&quot; &quot;workers&quot; If you wanted to keep just the state and total_income variables, you could take the sa3_income dataset and select just those variables: sa3_income %&gt;% select(state, total_income) ## # A tibble: 47,832 x 2 ## state total_income ## &lt;chr&gt; &lt;dbl&gt; ## 1 NSW 235853682 ## 2 NSW 253323356 ## 3 NSW 266908460 ## 4 NSW 264054166 ## 5 NSW 238214882 ## 6 NSW 273956768 ## 7 NSW 97561871 ## 8 NSW 102280707 ## 9 NSW 104914140 ## 10 NSW 104370174 ## # … with 47,822 more rows Or you could use - (minus) to remove the sa3 and sa3_name variables:4 sa3_income %&gt;% select(-sa3, -sa3_name) ## # A tibble: 47,832 x 14 ## sa3_sqkm sa3_income_perc… sa4_name gcc_name state occupation occ_short ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; ## 1 6511. 80 Capital… Rest of… NSW Clerical … Admin ## 2 6511. 76 Capital… Rest of… NSW Clerical … Admin ## 3 6511. 78 Capital… Rest of… NSW Clerical … Admin ## 4 6511. 76 Capital… Rest of… NSW Clerical … Admin ## 5 6511. 74 Capital… Rest of… NSW Clerical … Admin ## 6 6511. 79 Capital… Rest of… NSW Clerical … Admin ## 7 6511. 80 Capital… Rest of… NSW Clerical … Admin ## 8 6511. 76 Capital… Rest of… NSW Clerical … Admin ## 9 6511. 78 Capital… Rest of… NSW Clerical … Admin ## 10 6511. 76 Capital… Rest of… NSW Clerical … Admin ## # … with 47,822 more rows, and 7 more variables: prof &lt;chr&gt;, gender &lt;chr&gt;, ## # year &lt;dbl&gt;, median_income &lt;dbl&gt;, average_income &lt;dbl&gt;, ## # total_income &lt;dbl&gt;, workers &lt;dbl&gt; 8.4.1 Selecting groups of variables Sometimes it can be useful to keep or drop variables with names that have a certain characteristic; they begin with some text string, or end with one, or contain one, or have some other pattern altogether. You can use patterns and ‘select helpers’5 from the Tidyverse to help deal with these sets of variables. For example, if you want to keep just the SA3 and SA4 variables – ie the variables that start with &quot;sa&quot; – you could: sa3_income %&gt;% select(starts_with(&quot;sa&quot;)) ## # A tibble: 47,832 x 5 ## sa3 sa3_name sa3_sqkm sa3_income_percentile sa4_name ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 10102 Queanbeyan 6511. 80 Capital Region ## 2 10102 Queanbeyan 6511. 76 Capital Region ## 3 10102 Queanbeyan 6511. 78 Capital Region ## 4 10102 Queanbeyan 6511. 76 Capital Region ## 5 10102 Queanbeyan 6511. 74 Capital Region ## 6 10102 Queanbeyan 6511. 79 Capital Region ## 7 10102 Queanbeyan 6511. 80 Capital Region ## 8 10102 Queanbeyan 6511. 76 Capital Region ## 9 10102 Queanbeyan 6511. 78 Capital Region ## 10 10102 Queanbeyan 6511. 76 Capital Region ## # … with 47,822 more rows Or, instead, if you wanted to keep just the variables that contain &quot;income&quot;, you could: sa3_income %&gt;% select(contains(&quot;income&quot;)) ## # A tibble: 47,832 x 4 ## sa3_income_percentile median_income average_income total_income ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 80 52127 51306 235853682 ## 2 76 54894 53807 253323356 ## 3 78 57868 56405 266908460 ## 4 76 59025 57742 264054166 ## 5 74 59041 58286 238214882 ## 6 79 62741 61591 273956768 ## 7 80 66900 66869 97561871 ## 8 76 68943 69721 102280707 ## 9 78 71998 71859 104914140 ## 10 76 74277 74871 104370174 ## # … with 47,822 more rows And if you wanted to keep both the &quot;sa&quot; variables and the &quot;income&quot; variables, you could: sa3_income %&gt;% select(starts_with(&quot;sa&quot;), contains(&quot;income&quot;), ) ## # A tibble: 47,832 x 8 ## sa3 sa3_name sa3_sqkm sa3_income_perc… sa4_name median_income ## &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 10102 Queanbe… 6511. 80 Capital… 52127 ## 2 10102 Queanbe… 6511. 76 Capital… 54894 ## 3 10102 Queanbe… 6511. 78 Capital… 57868 ## 4 10102 Queanbe… 6511. 76 Capital… 59025 ## 5 10102 Queanbe… 6511. 74 Capital… 59041 ## 6 10102 Queanbe… 6511. 79 Capital… 62741 ## 7 10102 Queanbe… 6511. 80 Capital… 66900 ## 8 10102 Queanbe… 6511. 76 Capital… 68943 ## 9 10102 Queanbe… 6511. 78 Capital… 71998 ## 10 10102 Queanbe… 6511. 76 Capital… 74277 ## # … with 47,822 more rows, and 2 more variables: average_income &lt;dbl&gt;, ## # total_income &lt;dbl&gt; The full list of these handy select functions are provided with the ?tidyselect::select_helpers documentation, listed below: starts_with(): Starts with a prefix. ends_with(): Ends with a suffix. contains(): Contains a literal string. matches(): Matches a regular expression. num_range(): Matches a numerical range like x01, x02, x03. one_of(): Matches variable names in a character vector. everything(): Matches all variables. last_col(): Select last variable, possibly with an offset. 8.5 Filter with filter() The filter function takes a dataset and keeps observations (rows) that meet the rules. filter has one required first argument – the data – and then as many ‘conditions’ as you want to provide. 8.5.1 Logical operations: TRUE or FALSE The rules are logical conditions. 8.6 Arrange with arrange() 8.7 Group data with group_by() 8.8 Edit and add new variables with mutate() 8.8.1 Cases when you should use case_when() 8.9 Summarise data with summarise() 8.10 Joining datasets with *_join() From ABS Employee income by occupation and sex, 2010-11 to 2016-16↩ XXX cannot remember the source for this example; probably Hadley? Maybe somenone else?↩ ‘pass’ can also be used to mean ‘pipe’.↩ This is the same as keeping everything except the sa3 and sa3_name variables.↩ Explained in useful detail by the Tidyverse people at https://tidyselect.r-lib.org/reference/select_helpers.html↩ "]
]
